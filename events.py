import datetime
from threading import Lock

class list_node:
    def __init__(self):
        self._next = None 
    def get_key(self):
        raise NotImplemented

class event(list_node):
    def __init__(self, ev_type):
        self.event_id = self.generate_id()
        self.ev_type = ev_type
        list_node.__init__(self)

    def get_key(self):
        return self.event_id

    def generate_id(self):
        t = datetime.datetime.now()
        t = t - datetime.datetime(2015, 3, 14)
        t /= datetime.timedelta(microseconds=1)
        return hex(int(t))[2:]



    def __equal__(self, other):
        return self.event_id == other.event_id

    def __lt__(self, other):
        return self.event_id < other.event_id

    def __le__(self, other):
        return self.event_id <= other.event_id

    def __gt__(self, other):
        return self.event_id > other.event_id

    def __ge__(self, other):
        return self.event_id >= other.event_id

    def __ne__(self, other):
        return (not self==other)

class task_event(event):
    #These events will be checked by the server and dispatched to clients.
    def __init__(self, ev_type, task):
        event.__init__(self, ev_type)
        self.task = task
        #owner
    def to_dict(self):
        return {self.task.identifier: {self.ev_type: self.data}}
       
class event_linked_list:
    #an event list stores events generated by tasks(task_event instances). 
    #the server will try to find new events for the clients by event_ids
    #old and unreferenced entries should be cleaned, probably in a lazy manner
    #!!!need to explicitly guarantee thread safety and the event_ids are in ascending order
    def __init__(self):
        self.sentinel = list_node()
        self.sentinel._next = self.sentinel
        self.sentinel._prev = self.sentinel
        self.sentinel.event_id = '0'
        self.count = 0
        self.lock = Lock()

    def append(self, task_ev_node):
        self.count+=1
        task_ev_node._next = self.sentinel
        self.sentinel._prev._next = task_ev_node
        self.sentinel._prev = task_ev_node

    def popleft(self):
        #remove old entries
        if self.sentinel._next == self.sentinel:
            raise IndexError
        r = self.sentinel._next
        self.sentinel._next = self.sentinel._next._next
        self.count-=1
        return r

    def __getitem__(self, key):
        node = self.sentinel._next
        while not node == self.sentinel:
            if node.get_key() == key:
                return node
            elif node.get_key() < key:
                node = node._next
            else:
                raise KeyError
        raise KeyError

    def clean_old(self):
        pass


event_list = event_linked_list()
